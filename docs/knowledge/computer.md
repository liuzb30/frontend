# 三、计算机基础

> 关于编译原理，不需要理解非常深入，但是最基本的原理和概念一定要懂，这对于学习一门编程语言非常重要

## 编译原理

#### 1.理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序

代码就是我们写出来的源文件。

计算机将我们写的代码翻译成计算机可执行的二进制指令，这个过程叫编译。

#### 2.正则表达式的匹配原理和性能优化

#### 3.如何将 JavaScript 代码解析成抽象语法树(AST)

#### 4.base64 的编码原理

#### 5.几种进制的相互转换计算方法，在 JavaScript 中如何表示和转换

`parseInt(str, radix)` 将一个 radix 进制的 str 转化为十进制，`parseInt('23',8) // 19`，将八进制的‘23’转化为 10 进制的‘19’

`number.toString(radix)` 将一个数字转化为 radix 进制的数字字符串

## 网络协议

#### 1.理解什么是协议，了解 TCP/IP 网络协议族的构成，每层协议在应用程序中发挥的作用

#### 2.三次握手和四次挥手详细原理，为什么要使用这种机制

- 三次握手

  三次握手，是指建立一个 TCP 连接时，需要客户端和服务端总共发送三个报文。

  第一次握手：客户端请求建立连接，发送标志位 SYN 和序列号 seq=J 给服务端。（客户端进入 SYN_SENT 状态）

  第二次握手：服务端收到数据包后，由标志位 SYN=1 知道客户端请求建立连接，服务端将标志位 SYN 和 ACK 置为 1，ack=seq+1，并随机生成一个 seq=K,将该数据包发给客户端以确认连接请求（服务端进入 SYN_RCVD 状态）

  第三次握手：客户端收到确认后，检查数据是否正确，正确则向服务端发送确认信息，所以需要发送标志位 ACK 和确认号 ack。ack = K+ 1。服务端也检查数据是否正确，正确则连接建立成功。

- 四次握手

  四次挥手，是指断开一个 TCP 连接时，需要客户端和服务端总共发送 4 个包已确认连接的断开。

  第一次挥手：客户端发起断开连接请求，向服务端发送标志位 FIN,设置序列号 seq=j。

  第二次挥手：服务端收到客户端的断开请求，向客户端发送标志位 ACK,确认号 ack=j+1，表示同意断开连接请求。

  第三次挥手：服务端向客户端发送标志位 FIN，设置序列号 seq=k，请求关闭连接。

  第四次挥手：客户端收到服务端的 FIN 报文，向服务端发送 ACK 的报文段，然后客户端进入 TIME_WAIT 状态。服务端收到客户端的确认报文后，就关闭连接。此时，客户端等待 2MSL 的时间后依然没有收到回复，则证明服务端已经断开连接。

- 为什么需要三次握手？

  三次握手是为了避免服务端的资源浪费。假设客户端发了一个请求，由于网络的原因，很久才被服务端收到，服务端以为这是一个实时请求，就跟客户端建立了连接。由于客户端并没有建立连接的请求，就不理睬服务端。但服务端以为连接已经建立，就一直在等待客户端发来数据。这样，服务端的很多资源就白白浪费了。

  TCP 三次握手跟现实生活中的人与人打电话是很类似的

- 为什么连接的时候是三次握手，关闭的时候却是四次握手？

  因为建立连接时，服务端收到客户端的请求后，可以直接发送 SYN 和 ACK 报文，所以只需要三次握手。

  而关闭连接时，当客户端发出 FIN 报文时，只是表示客户端不再像服务端发送数据了。所以当服务端收到客户端的断开请求时，向客户端发送 ACK 报文表示已经知道。但是服务端还是可以继续给客户端发送数据（TCP 是全双工模式），所以不会马上关闭 socket，直到服务端数据发送完毕，向客户端发送 FIN 报文时，这个时候服务端也没有数据要发送了，这个时候两边才断开连接。

- 为什么要等待 2MSL？

  **MSL**：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。

  **第一点：保证 TCP 协议的全双工连接能够可靠关闭**：

  为了保证服务端能够收到 ACK 报文

  **第二点：保证这次连接的重复数据段从网络中消失**

[一文彻底搞懂 TCP 三次握手和四次挥手](https://blog.csdn.net/a519640026/article/details/104448480/)

#### 3.有哪些协议是可靠，TCP 有哪些手段保证可靠交付

TCP 的协议：FTP(文件传输协议)、Telnet（远程登录协议）、SMTP、POP3（邮件传输协议）、HTTP 协议等。

三次握手和四次挥手

#### 4.DNS 的作用、DNS 解析的详细过程，DNS 优化原理

**DNS 的作用**：它是互联网的一项服务，是一个将域名和 IP 地址互相映射的分布式数据库，能够使人更为方便地访问互联网。

**DNS 解析过程**：本地 hosts 文件 -> 本地 DNS 解析器缓存 -> 本地 DNS 服务器 -> 上一级 DNS 服务器(转发模式) -> 13 台根 DNS(非转发模式) -> 顶级域名服务器 ->下一级域名服务器（直到找到为止）。

**DNS 优化**：

- 减少 DNS 的请求次数；（项目中减少不同域名的 http 请求）
- 进行 DNS 预获取 。（减少用户的等待时间，提升用户体验 。）

默认情况下浏览器会对页面中和当前域名（正在浏览网页的域名）不在同一个域的域名进行预获取，并且缓存结果，这就是隐式的 DNS Prefetch。如果想对页面中没有出现的域进行预获取，那么就要使用显示的 DNS Prefetch 了。

```html
<meta http-equiv="x-dns-prefetch-control" content="on" />
<link rel="dns-prefetch" href="//www.itechzero.com" />
<link rel="dns-prefetch" href="//api.share.baidu.com" />
<link rel="dns-prefetch" href="//bdimg.share.baidu.com" />
```

#### 5.CDN 的作用和原理

[简单地聊聊 CDN 原理作用及实现方法](https://www.wc1234.cn/2046.html)

#### 6.HTTP 请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么

#### 7.HTTP 所有状态码的具体含义，看到异常状态码能快速定位问题

- **1XX：信息状态码**
- **2XX：成功状态码**
  - 200: 正常返回
  - 201：Created 请求成功并且服务器创建了新的资源
  - 202：Accepted 服务器接受请求但未处理
- **3XX：重定向**
  - 301：Moved Permanently 永久重定向
  - 302：Found 临时性重定向
  - 303：See Other 临时性重定向，且总是使用 GET 请求新的 URI。
  - 304：Not Modified 资源未过期
- **4XX：客户端错误**
  - 400 Bad Request 服务器无法理解请求的格式
  - 401 Unauthorized 请求未授权
  - 403 Forbidden 禁止访问
  - 404 Not found 找不到对应的资源
- **5XX: 服务器错误**
  - 500 Internal Server Error 最常见的服务器端错误。
  - 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。

#### 8.HTTP1.1、HTTP2.0 带来的改变

#### HTTP1.1

- 缓存处理

  - 在 `HTTP1.0` 中主要使用 `header` 里的 `If-Modified-Since,Expires` 来做为缓存判断的标准
  - `HTTP1.1` 则引入了更多的缓存控制策略例如 `Entity tag，If-Unmodified-Since, If-Match, If-None-Match` 等更多可供选择的缓存头来控制缓存策略。

- 带宽优化及网络连接的使用

  `HTTP1.0` 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，`HTTP1.1` 则在请求头引入了 `range` 头域，它允许只请求资源的某个部分，即返回码是 `206（Partial Content）`，这样就方便了开发者自由的选择以便于充分利用带宽和连接。

- 错误通知的管理

  在 `HTTP1.1` 中新增了` 24` 个错误状态响应码，如 `409（Conflict）`表示请求的资源与资源的当前状态发生冲突；`410（Gone）`表示服务器上的某个资源被永久性的删除。

- Host 头处理

  在 `HTTP1.0` 中认为每台服务器都绑定一个唯一的 `IP` 地址，因此，请求消息中的 `URL` 并没有传递主机名 `（hostname）`。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机`（Multi-homed Web Servers）`，并且它们共享一个 `IP` 地址。`HTTP1.1` 的请求消息和响应消息都应支持 `Host` 头域，且请求消息中如果没有 `Host` 头域会报告一个错误`（400 Bad Request）`。

- 长连接

  `HTTP 1.1` 支持长连接`（PersistentConnection）`和请求的流水线`（Pipelining）`处理，在一个 `TCP` 连接上可以传送多个 `HTTP` 请求和响应，减少了建立和关闭连接的消耗和延迟，在 `HTTP1.1` 中默认开启 `Connection： keep-alive`，一定程度上弥补了 `HTTP1.0` 每次请求都要创建连接的缺点。

#### HTTP2.0

- 二进制格式

  `HTTP1.x` 的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 `0` 和 `1` 的组合。基于这种考虑 `HTTP2.0` 的协议解析决定采用二进制格式，实现方便且健壮。

- 多路复用

  即连接共享，即每一个 `request` 都是是用作连接共享机制的。一个 `request` 对应一个 `id`，这样一个连接上可以有多个 `request`，每个连接的 `request` 可以随机的混杂在一起，接收方可以根据 `request` 的 `id` 将 `request` 再归属到各自不同的服务端请求里面。

- 头部压缩

  `HTTP1.x` 的 `header` 带有大量信息，而且每次都要重复发送，`HTTP2.0` 使用 `encoder` 来减少需要传输的 `header` 大小，通讯双方各自 `cache` 一份 `header fields` 表，既避免了重复 `header` 的传输，又减小了需要传输的大小。

- 服务端推送

  `HTTP2.0`具有 `server push` 功能。

#### 9.HTTPS 的加密原理，如何开启 HTTPS，如何劫持 HTTPS 请求

加密原理：

- 浏览器发出请求
- 服务器发送数字证书（包含服务器的公钥）
- 浏览器用预置的 CA 列表验证证书，如果有问题，则提示风险
- 浏览器生产随机的对称密钥，用服务器的公钥加密
- 服务器用自己的私钥解密，得到对称密钥
- 双方都知道了对称密钥，用它来加密通信

重点：

为了保证浏览器能安全把对称密钥传给服务器，双方用对称密钥来通讯。需要对对称密钥进行加密，就得服务器把公钥发送给浏览器；而服务器为了能安全发送公钥，就得用数字证书来加密。

- 为了对数据进行加密传输，引入了对称加密（密钥如何传输）
- 为了解决密钥传输问题，引入了非对称加密 RSA（加解密速度慢）
- 为了解决速度慢的问题，想出了非对称加密+对称加密（有可能遇到中间人攻击）
- 为了解决公钥的正确性，引入了数字签名和认证中心 CA(浏览器会内置顶层的 CA 证书)
  - 对公钥和个人信息进行 hash 得到消息摘要，然后用 CA 的私钥对摘要加密
  - 浏览器对公钥和个人信息进行 hash 得到消息摘要，然后用 CA 的公钥进行解密，对消息摘要进行比对。

参考文章：[【一个故事讲完 https】](https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA)

#### 10.理解 WebSocket 协议的底层原理、与 HTTP 的区别

WebSocket 是基于 HTTP 协议的，或者说借用了 HTTP 协议来完成一部分握手。握手成功后就建立了 websocket 连接，然后服务端就可以向客户端推送消息了。

ajax 轮询 ：每隔几秒像服务器发送请求，询问是否有新消息。（需要服务端有很快的处理速度和资源）

long poll：原理和 ajax 差不多，不过采用的的阻塞模型，也就是发起连接后，保持连接，直到服务器返回消息，返回后，客户端再重新发起消息，周而复始。（需要服务端有很高的并发）

参考文章：[看完让你理解 WebSocket 原理](https://blog.csdn.net/jing_80/article/details/82111423)

## 设计模式

#### 1.熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等

代理模式分为：保护代理和虚拟代理

单例模式：全局只有一个实例

策略模式：有两个部分，策略类和环境类。策略类封装了具体的算法，环境类接受用户的请求，并把请求委托给策略类。

装饰器模式：在不改变原有功能的基础上增加新的功能。

参考文章：[【设计模式】](https://zxpsuper.github.io/Demo/advanced_front_end/js/design.html#设计模式)

[js 设计模式--代理模式](https://segmentfault.com/a/1190000017743794)

#### 2.发布订阅模式和观察者模式的异同以及实际应用

#### 3.可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用
